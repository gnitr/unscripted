{% extends "base.html" %}
{% load unsctags %}

{% block css %}
    {{ block.super }}
    <style type="text/css">
        #vis-container {
            width: 100%;
            height: 100%;
        }
        
        #cnv-world {
            border: 1px solid grey;
            width: 100%;
            height: 100%;
        }
        
        #info-box {
        }
        
    </style>
{% endblock %}

{% block body %}
    <div id="viewer">
        <div id="vis-container">
        </div>
        <div id="info-box">
        </div>
    </div>
{% endblock %}

{% block js %}
    {{ block.super }}
    {# https://bl.ocks.org/mbostock/d1f7b58631e71fbf9c568345ee04a60e #}
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous"></script>
        
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/2.5.0/babylon.js"></script>
    <script src="/static/unscvis/utils.js"></script>
 
    <script>
    $(function(){
    	window.unscutils.elastic_element($('#viewer'), function() {}, 10, 10);
    	
    	window.world = {{ world.get_api_dict|json }};
        window.things = {};
        window.vis = {
            canvas: null,
            context: null,
            engine: null,
            scene: null,
            camera: null,
            draw_cycle: 0,
            camera_target: null,
        };
      
        function request_world() {
            $.getJSON('http://localhost:8000/api/1/worlds/'+window.world.id+'/things', function(response) {
                render_things(response.data.items);
            });
        }
        
        function render_things(things) {
            var cx = get_canvas_context();
            var vis = window.vis;
            
            vis.draw_cycle += 1;
            if (vis.draw_cycle > 1) vis.draw_cycle = 0;
            
            // add/update things on scene
            $.each(things, function(i, thing) {
                draw_thing(thing);
            });
            
            // remove things from scene
            $.each(window.things, function(i, thing) {
                if (thing.draw_cycle != vis.draw_cycle) {
                    var mesh = vis.scene.getMeshByName(thing.id);
                    mesh.dispose();
                    delete window.things[thing.id];
                }
            });
        }
        
        function draw_thing(thing) {
            var vis = window.vis;
            
            var box = vis.scene.getMeshByName(thing.id);
            if (!box) {
                box = BABYLON.MeshBuilder.CreateBox(
                        thing.id,
                        {
                            width: thing.dims[0],
                            height: thing.dims[1],
                            depth: thing.dims[2],
                        }, 
                        vis.scene
                    );
                
                var material = new BABYLON.StandardMaterial("material01", vis.scene);
                material.ambientColor = new BABYLON.Color3(1,0,0);
                box.material = material;
            }
            box.position.x = thing.pos[0];
            box.position.y = thing.pos[1];
            box.position.z = thing.pos[2];
            box.position.y += box.getBoundingInfo().boundingBox.extendSize.y;
            //box.position.y = 10;
            window.things[thing.id] = thing;
            thing.draw_cycle = vis.draw_cycle;
        }
        
        function create_scene() {
            var vis = window.vis;
            vis.scene = new BABYLON.Scene(vis.engine);
            var world = window.world;
            
            vis.radius = window.world.dims[0];
            if (window.world.dims[0] < window.world.dims[1]) {
                vis.radius = window.world.dims[1];
            }
            
            vis.camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 4, vis.radius * 2, BABYLON.Vector3.Zero(), vis.scene);
            vis.camera.attachControl(vis.canvas, true);
            vis.camera.lowerRadiusLimit = 10;
            vis.camera.upperRadiusLimit = 3 * vis.radius;
            // we prevent camera from going too low above ground
            // (i.e. pi/2 is ground level, 0 is peak, here 0.01 is 1% above ground level)
            vis.camera.upperBetaLimit = (Math.PI / 2) * (1 - 0.01);
            window.vis.camera.setTarget(new BABYLON.Vector3(window.world.dims[0]/2,0,window.world.dims[1]/2))

            // Add lights to the scene
            var light1 = new BABYLON.HemisphericLight("daylight", new BABYLON.Vector3(0.5, 1, 0.3), vis.scene);
            light1.intensity = 0.7;
            //light1.diffuse = new BABYLON.Color3(1, 1, 1);
            //light1.groundColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            vis.scene.ambientColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            //var light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(0, 1, -1), vis.scene);

            // Add and manipulate meshes in the scene
            //var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter:2}, vis.scene);
            //var plane = BABYLON.MeshBuilder.CreatePlane("map", {width: window.world.dims[0], height: window.world.dims[1]}, vis.scene);
            var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: window.world.dims[0], height: window.world.dims[2], subdivisions: 4}, vis.scene);
            ground.position.x =  ground.getBoundingInfo().boundingBox.extendSize.x;
            ground.position.y =  ground.getBoundingInfo().boundingBox.extendSize.y;
            ground.position.z =  ground.getBoundingInfo().boundingBox.extendSize.z;

            var material = new BABYLON.StandardMaterial("material01", vis.scene);
            material.ambientColor = new BABYLON.Color3(0.5,0.5,0.5);
            ground.material = material;

            // add visible axis
            draw_axis([world.dims[0],0,0], [1,0,0], 'axis-x');
            draw_axis([0,world.dims[1],0], [0,1,0], 'axis-y');
            draw_axis([0,0,world.dims[2]], [0,0,1], 'axis-z');
            
            vis.scene.registerBeforeRender(function () {
                // https://babylonjsguide.github.io/basics/Cameras
                var vis = window.vis;
            	
                if (vis.camera.position.y < .5) {
                    //var diff = 0 - camera.position.y;
                    //camera.position.y = 1.5 + diff;
                    // doesn't work too well, the user camera movement satys stuck to the limit for a while
                    //vis.camera.setPosition(new BABYLON.Vector3(vis.camera.position.x,0.5,vis.camera.position.z));
                }
            });

            return vis.scene;
        }

        function draw_axis(dir, color, name) {
            var points;
            points = [new BABYLON.Vector3(0,0,0), new BABYLON.Vector3(dir[0], dir[1], dir[2])];
            var line = BABYLON.MeshBuilder.CreateLines(name, {points: points}, vis.scene);
            line.color = new BABYLON.Color3(color[0], color[1], color[2]);
        }

        function get_canvas_context() {
            var ret = window.vis.context;
            
            if (!ret) {
                var $div = $('#vis-container');
                var vis = window.vis;
                
                if (0) {
                    var width = $div.width();
                    var height = $div.height();
                    $('#vis-container').html('<canvas id="cnv-world" width="'+width+'" height="'+height+'"></canvas>');
                    canvas = $('#cnv-world')[0];
                    ret = vis.canvas.getContext('2d');
                } else {
                    $('#vis-container').html('<canvas id="cnv-world" touch-action="none"></canvas>');
                    vis.canvas = $('#cnv-world')[0];
                    vis.engine = new BABYLON.Engine(vis.canvas, true);
                    ret = create_scene();

                    vis.engine.runRenderLoop(function () {
                        vis.scene.render();
                    });

                    window.addEventListener("resize", function () {
                        vis.engine.resize();
                    });
                    
                    vis.actionManager = new BABYLON.ActionManager(vis.scene);
                    vis.actionManager.registerAction(
                        new BABYLON.ExecuteCodeAction(
                            BABYLON.ActionManager.OnPickTrigger, 
                            function () {console.log('ACTION')}
                            )
                        );

                    window.addEventListener("click2", function (e) {
                        if (window.vis.scene) {
                            var pick_info = window.vis.scene.pick(window.vis.scene.pointerX, window.vis.scene.pointerY);
                            if (pick_info.hit) {
                                var vis = window.vis;
                                var mesh = pick_info.pickedMesh;
                                console.log(mesh.name);
                                console.log(mesh);

                                vis.camera.setTarget(new BABYLON.Vector3(mesh.position.x,0,mesh.position.z));
                            }
                        }
                    });
                }
                vis.context = ret;
            }
            return ret;
        }
        
        request_world();
        
        window.setInterval(request_world, 1000);
    });
   </script>
{% endblock %}
